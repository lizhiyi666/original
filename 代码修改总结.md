# 代码修改总结 - POI类别偏序约束投影方法实现

## 问题描述

原始需求：在POI类别的采样阶段使用Constraint Discrete Diffusion中的投影方法，实现满足POI类别间的偏序关系的POI序列生成，g(⋅)设计方案参考项目中的文件。

## 解决方案

基于项目中的 `g(⋅)设计方案.md` 和《Constrained Discrete Diffusion》论文，实现了一个完整的约束投影系统，可以在采样阶段强制满足POI类别的偏序关系。

## 核心实现

### 1. 约束函数 g(·) 实现 (constraint_projection.py)

根据设计文档实现了可微的约束函数：

```python
g_total(Y) = Σ_k Σ_{i<j} P_{B_k}(i) · P_{A_k}(j)
```

**含义**：
- 对于约束 (A_k, B_k)，表示 B_k 不能出现在 A_k 之前
- P_{A_k}(i) 是位置 i 生成类别集合 A_k 的概率
- P_{B_k}(i) 是位置 i 生成类别集合 B_k 的概率
- 当 B 出现在 A 之前时，乘积 P_B(i) · P_A(j) 会很大，累加即为违规惩罚

**关键特性**：
- ✅ 完全可微，支持梯度计算
- ✅ 使用矩阵运算优化，计算高效
- ✅ 支持批量处理

### 2. ALM 投影方法

使用增广拉格朗日方法（Augmented Lagrangian Method）进行投影：

```python
优化目标: min_y D_KL(y || y_model) + λ·max(0, g(y) - τ) + β/2·max(0, g(y) - τ)²
```

**组成部分**：
1. **D_KL(y || y_model)**: KL散度，保持与模型预测接近
2. **λ·max(0, g(y) - τ)**: 拉格朗日惩罚项，软约束
3. **β/2·max(0, g(y) - τ)²**: 二次惩罚项，加速收敛

**算法流程**：
```
For iter = 1 to N:
  1. 计算约束违规 g(y)
  2. 计算总损失 L = KL + λ·Δg + β/2·Δg²
  3. 梯度下降更新 y
  4. 重新归一化为概率分布
  5. 更新拉格朗日乘子 λ
```

### 3. 采样流程集成 (diffusion_transformer.py)

在扩散模型的采样过程中集成投影：

**修改位置**：
1. **初始化阶段** (`__init__`)
   - 添加投影参数
   - 创建 `ConstraintProjection` 实例

2. **采样步骤** (`p_sample`)
   - 在每个去噪步骤后应用投影
   - 只对类别位置应用，不影响POI位置

3. **快速采样** (`sample_fast`)
   - 从 batch 中提取偏序矩阵
   - 转换为约束列表格式
   - 传递给 `p_sample` 方法

**代码示例**：
```python
# 在 p_sample 中
if self.use_constraint_projection and po_constraints is not None:
    model_log_prob = self.constraint_projector.apply_projection_to_category_positions(
        model_log_prob, po_constraints, batch.category_mask
    )
```

### 4. 配置系统 (configs.py, Marionette.yaml)

添加了完整的配置支持：

```yaml
# config/model/Marionette.yaml
use_constraint_projection: false  # 启用/禁用投影
projection_tau: 0.0                # 约束阈值
projection_lambda: 1.0             # 初始拉格朗日乘子
projection_alm_iters: 5            # ALM 迭代次数
projection_frequency: 1            # 投影频率（每隔几步应用一次）
```

## 文件清单

### 新增文件

1. **constraint_projection.py** (259行)
   - `ConstraintProjection` 类：核心投影算法
   - `parse_po_matrix_to_constraints()`: 偏序矩阵转换
   - `compute_constraint_violation()`: 计算违规度
   - `project_to_constraint_space()`: ALM 投影

2. **CONSTRAINT_PROJECTION_README.md** (200+行)
   - 完整的使用说明
   - 参数调优建议
   - 常见问题解答

3. **example_constraint_projection.py** (250+行)
   - 三种使用方法的示例代码
   - 参数调优指南
   - 约束验证函数

4. **test_constraint_projection.py** (200+行)
   - 单元测试
   - 集成测试
   - 功能验证

5. **VALIDATION_CHECKLIST.md** (150+行)
   - 代码验证清单
   - 实现要点检查
   - 测试建议

### 修改文件

1. **discrete_diffusion/diffusion_transformer.py**
   - 导入投影模块
   - 添加投影参数和初始化
   - 修改 `p_sample()` 方法
   - 修改 `sample_fast()` 方法

2. **configs.py**
   - 在 `instantiate_model()` 中读取投影配置
   - 传递参数给 `DiffusionTransformer`

3. **config/model/Marionette.yaml**
   - 添加投影相关配置项

4. **.gitignore**
   - 添加 Python 缓存文件排除规则

## 使用方法

### 方法1：通过配置文件（推荐）

1. 修改 `config/model/Marionette.yaml`:
```yaml
use_constraint_projection: true
projection_tau: 0.0
projection_lambda: 1.0
projection_alm_iters: 5
```

2. 正常运行采样:
```bash
sh sample_evaluation.sh <your_wandb_runid>
```

### 方法2：代码中直接使用

```python
from discrete_diffusion.diffusion_transformer import DiffusionTransformer

diffusion_model = DiffusionTransformer(
    diffusion_step=200,
    type_classes=9,
    poi_classes=3477,
    use_constraint_projection=True,  # 启用投影
    projection_tau=0.0,
    projection_lambda=1.0,
    projection_alm_iters=5
)
```

### 方法3：独立使用投影模块

```python
from constraint_projection import ConstraintProjection

projector = ConstraintProjection(
    num_classes=19,
    type_classes=9,
    num_spectial=4
)

# 应用投影
projected = projector.apply_projection_to_category_positions(
    log_probs, constraints, category_mask
)
```

## 参数说明

### projection_tau (约束阈值)
- **默认值**: 0.0
- **含义**: 允许的最大约束违规量
- **建议**: 保持为 0（严格约束）

### projection_lambda (拉格朗日乘子)
- **默认值**: 1.0
- **含义**: 约束惩罚的强度
- **建议**: 
  - 0.5 - 宽松约束
  - 1.0 - 标准（推荐）
  - 5.0 - 严格约束

### projection_alm_iters (迭代次数)
- **默认值**: 5
- **含义**: 每个去噪步骤的投影迭代次数
- **建议**:
  - 3 - 快速测试
  - 5 - 平衡（推荐）
  - 10 - 高精度

### projection_frequency (投影频率)
- **默认值**: 1
- **含义**: 每隔几步应用一次投影（1 表示每步都应用）
- **建议**:
  - 1 - 每步都应用（最严格，约束满足率最高）
  - 2-5 - 每隔几步应用（平衡速度和约束）
  - 10+ - 较少应用（速度快，但约束满足率可能降低）
- **使用场景**:
  - 高质量采样: 设为 1
  - 快速测试: 设为 5-10
  - 计算资源有限: 根据需要调整

## 工作原理

### 采样流程（启用投影时）

```
For 每个去噪步骤 t = T-1 down to 0:
  1. 模型预测: log_prob = model(x_t, t)
  2. 【新增】投影步骤:
     a. 从 batch 提取偏序矩阵
     b. 转换为约束列表
     c. 应用 ALM 投影: log_prob = project(log_prob)
  3. Gumbel 采样: x_{t-1} ~ Gumbel(log_prob)
```

### 投影过程

```
输入: 模型预测的 log_prob, 偏序约束
输出: 满足约束的 log_prob_projected

For iter = 1 to alm_iters:
  1. 计算违规: g = Σ_{i<j} P_B(i) · P_A(j)
  2. 计算损失: L = KL(y||y_model) + λ·max(0,g) + β/2·max(0,g)²
  3. 反向传播: ∇L
  4. 梯度更新: y ← y - α·∇L
  5. 归一化: y ← normalize(y)
  6. 更新乘子: λ ← λ + β·max(0,g)
```

## 验证方法

### 检查约束满足率

使用 `example_constraint_projection.py` 中的验证函数：

```python
from example_constraint_projection import verify_constraint_satisfaction

satisfaction_rate, violations = verify_constraint_satisfaction(
    sequences=generated_sequences,
    po_matrix=po_matrix,
    num_spectial=4
)

print(f"约束满足率: {satisfaction_rate:.2%}")
print(f"违规次数: {violations}")
```

### 运行测试（需要 PyTorch 环境）

```bash
python test_constraint_projection.py
```

## 性能考虑

### 计算开销
- 每个去噪步骤额外耗时: ~几毫秒（取决于迭代次数）
- 总采样时间增加: ~10-30%（alm_iters=5时）

### 优化建议
1. 减少迭代次数（如 3 次）
2. 只在后期去噪步骤应用投影
3. 使用 GPU 加速

## 理论基础

### 参考文档
1. **g(⋅)设计方案.md** - 项目中的约束函数设计
2. **Constrained Discrete Diffusion.pdf** - 理论论文
3. **partial_order_loss.py** - 训练阶段的偏序损失

### 关键创新
- 将训练时的软约束（损失函数）扩展到采样阶段（硬约束）
- 使用 ALM 方法在保持生成质量的同时满足约束
- 矩阵化实现提高计算效率

## 下一步建议

1. **测试验证**
   - 在实际数据上测试约束满足率
   - 对比启用/禁用投影的生成质量
   - 评估下游任务性能

2. **参数调优**
   - 根据约束满足率调整 lambda
   - 根据采样速度调整 alm_iters
   - 实验不同的 tau 值

3. **可能的改进**
   - 实现自适应迭代次数
   - 添加约束分组优化
   - 支持软约束模式

## 联系与支持

详细文档请参考：
- `CONSTRAINT_PROJECTION_README.md` - 英文详细说明
- `example_constraint_projection.py` - 使用示例
- `VALIDATION_CHECKLIST.md` - 验证清单

如有问题，请检查这些文档或提出 Issue。
